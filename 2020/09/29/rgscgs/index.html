<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>2020 年你应该知道的 React 库 | Bin</title><meta name="description" content="声明：本文为译文，原文链接：https:&#x2F;&#x2F;www.robinwieruch.de&#x2F;react-libraries 版权属于：桃翁  React 生态圈.xmind React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经"><meta name="author" content="wuyanbin"><meta name="copyright" content="wuyanbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/bin.ico"><link rel="canonical" href="http://wuyanbin.top/2020/09/29/rgscgs/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="2020 年你应该知道的 React 库"><meta property="og:url" content="http://wuyanbin.top/2020/09/29/rgscgs/"><meta property="og:site_name" content="Bin"><meta property="og:description" content="声明：本文为译文，原文链接：https:&#x2F;&#x2F;www.robinwieruch.de&#x2F;react-libraries 版权属于：桃翁  React 生态圈.xmind React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经"><meta property="og:image" content="http://wuyanbin.top/img/avatar.jpeg"><meta property="article:published_time" content="2020-09-29T07:20:58.000Z"><meta property="article:modified_time" content="2020-11-17T12:50:09.664Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-11-17 20:50:09'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/avatar.jpeg'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B-React"><span class="toc-number">1.</span> <span class="toc-text">如何开始 React</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">React 状态管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-React-%E8%B7%AF%E7%94%B1"><span class="toc-number">3.</span> <span class="toc-text">使用 React 路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">React 中的样式库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-UI-%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">React UI 库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E5%8A%A8%E7%94%BB"><span class="toc-number">6.</span> <span class="toc-text">React 动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E5%9B%BE%E8%A1%A8%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text">React 可视化和图表库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">React 中的表单库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text">React 中的数据获取库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">10.</span> <span class="toc-text">React 类型检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">11.</span> <span class="toc-text">React 代码风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E8%AE%A4%E8%AF%81"><span class="toc-number">12.</span> <span class="toc-text">React 认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E4%B8%BB%E6%9C%BA"><span class="toc-number">13.</span> <span class="toc-text">React 主机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E6%B5%8B%E8%AF%95"><span class="toc-number">14.</span> <span class="toc-text">React 测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E-React-%E7%9A%84%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">15.</span> <span class="toc-text">用于 React 的工具库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84"><span class="toc-number">16.</span> <span class="toc-text">react 和不可变的数据机构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">React 国际化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">18.</span> <span class="toc-text">React 富文本编辑器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E4%B8%AD%E7%9A%84%E6%94%AF%E4%BB%98"><span class="toc-number">19.</span> <span class="toc-text">React 中的支付</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">20.</span> <span class="toc-text">React 中的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reac-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8"><span class="toc-number">21.</span> <span class="toc-text">Reac 桌面应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">22.</span> <span class="toc-text">React 的移动开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REACT-VR-AR"><span class="toc-number">23.</span> <span class="toc-text">REACT VR&#x2F;AR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA-React-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">24.</span> <span class="toc-text">为 React 设计原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA-React-%E4%B9%A6%E5%86%99%E6%96%87%E6%A1%A3"><span class="toc-number">25.</span> <span class="toc-text">为 React 书写文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">26.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%9E%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BC%8F"><span class="toc-number">26.1.</span> <span class="toc-text">小型应用程式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">26.2.</span> <span class="toc-text">中型应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">26.3.</span> <span class="toc-text">大型应用程序</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Bin</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">2020 年你应该知道的 React 库</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-29T07:20:58.000Z" title="发表于 2020-09-29 15:20:58">2020-09-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-17T12:50:09.664Z" title="更新于 2020-11-17 20:50:09">2020-11-17</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>声明：本文为译文，原文链接：<a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-libraries">https://www.robinwieruch.de/react-libraries</a> 版权属于：桃翁</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/152077/1601364432939-1d6f09d6-9544-4bf6-b509-15a30245a2fa.png#align=left&display=inline&height=5253&margin=%5Bobject%20Object%5D&name=React%E7%94%9F%E6%80%81%E5%9C%88.png&originHeight=5253&originWidth=2385&size=868896&status=done&style=none&width=2385" alt="React生态圈.png"><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2020/xmind/152077/1601364450272-c562570b-6dbe-4983-abd9-646da1e43b54.xmind?_lake_card=%7B%22uid%22:%221601364450086-0%22,%22src%22:%22https://www.yuque.com/attachments/yuque/0/2020/xmind/152077/1601364450272-c562570b-6dbe-4983-abd9-646da1e43b54.xmind%22,%22name%22:%22React%E7%94%9F%E6%80%81%E5%9C%88.xmind%22,%22size%22:145436,%22type%22:%22application/vnd.xmind.workbook%22,%22ext%22:%22xmind%22,%22progress%22:%7B%22percent%22:99%7D,%22status%22:%22done%22,%22percent%22:0,%22id%22:%22ZiW0h%22,%22card%22:%22file%22%7D">React 生态圈.xmind</a></p>
<p>React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，<br>然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 <a target="_blank" rel="noopener" href="https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/">当我从 Angular 切换到 React</a>，我绝对经历了它作为 React 的优势。<br>只有通过 React，您才能使用<a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-function-component">函数组件</a>和 <a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-pass-props-to-component">props</a> 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。<br>下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。</p>
<h2 id="如何开始-React"><a href="#如何开始-React" class="headerlink" title="如何开始 React"></a>如何开始 React</h2><p>如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/create-react-app">create-react-app(CRA)</a>。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。<br>如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。<br>如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试<a target="_blank" rel="noopener" href="https://www.robinwieruch.de/minimal-react-webpack-babel-setup">从头开始设置 React 项目</a>。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。<br>如果你想选择一个自定义样板项目，试着缩小你的要求。 样板文件应该是最小的，不要试图解决所有问题。 它应该针对你的问题。 例如，<a target="_blank" rel="noopener" href="https://github.com/rwieruch/gatsby-firebase-authentication">gatsby-Firebase-authentication</a> 样板文件只在 Gatsby.js 中为您提供了完整的 Firebase 身份验证机制，但是其他所有内容都被省略了。<br><strong>建议：</strong></p>
<ul>
<li>create-react-app for React beginners/advanced</li>
<li>Gatsby.js for static websites in React</li>
<li>Next.js for server-side rendered React</li>
<li>custom React project to understand the underlying tools</li>
</ul>
<h2 id="React-状态管理"><a href="#React-状态管理" class="headerlink" title="React 状态管理"></a>React 状态管理</h2><p>React 带有内置的 hooks 来管理局部状态: useState、 useReducer 和 useContext。 所有这些都可以在 React 中用于复杂的本地状态管理。 它甚至可以模拟 Redux(Redux 是 React 的一个流行的状态管理库)。<br>所有 React 的内置 hooks 都非常适合本地状态管理。 当涉及到远程数据的状态管理时，如果远程数据带有 GraphQL 端点，我建议使用 Apollo Client。Apollo Client 的替代方案是 <a target="_blank" rel="noopener" href="https://github.com/FormidableLabs/urql">urql</a> 和 <a target="_blank" rel="noopener" href="https://relay.dev/">Relay</a>。<br>如果远程数据不是来自 GraphQL 端点，请尝试使用 React 的 Hooks 来管理它。 如果不行，像   <a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-redux-tutorial">Redux</a> 或者 <a target="_blank" rel="noopener" href="https://mobx.js.org/">MobX</a>/<a target="_blank" rel="noopener" href="https://mobx-state-tree.js.org/">Mobx State tree</a> 这样的解决方案可能会有所帮助。<br>如果你想了解更多细节，请访问我的<a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-state">综合状态管理反应教程</a>。<br><strong>推荐：</strong></p>
<ul>
<li>局部状态: React 的 useState, useReducer, useContext Hooks</li>
<li>通过 Graph QL 的远程状态: Apollo Client</li>
<li>通过 REST 的远程状态: React Hooks or Redux/MobX/Mobx State Tree</li>
</ul>
<h2 id="使用-React-路由"><a href="#使用-React-路由" class="headerlink" title="使用 React 路由"></a>使用 React 路由</h2><p>路由在 React 中起着重要作用。 毕竟，React 可以帮助您实现在客户端处理路由的单页应用程序。 当介绍一个复杂的路由 的时候，有好几个路由解决方案。 最值得推荐的解决方案是 <a target="_blank" rel="noopener" href="https://github.com/ReactTraining/react-router">React Router</a>。<br>在您引入路由以前，您可以先尝试 <a target="_blank" rel="noopener" href="https://www.robinwieruch.de/conditional-rendering-react">React 的条件渲染</a>，它虽然不是路由的合理替代，但是小型应用中以及足够用了。<br><strong>建议:</strong></p>
<ul>
<li>React Router</li>
</ul>
<h2 id="React-中的样式库"><a href="#React-中的样式库" class="headerlink" title="React 中的样式库"></a>React 中的样式库</h2><p>虽然关于 React 样式处理有很多解决方法，但是作为一个 React 初学者，刚开始使用内联样式和基本 CSS 是很好的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#39;.&#x2F;Headline.css&#39;;</span><br><span class="line">const Headline &#x3D; (&#123; title &#125;) &#x3D;&gt;</span><br><span class="line">&lt;h1 className&#x3D;&quot;headline&quot; style&#x3D;&#123;&#123; color: &#39;blue&#39; &#125;&#125;&gt;</span><br><span class="line">  &#123;title&#125;</span><br><span class="line">&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>虽然内联样式可以用 JavaScript 在 React 中动态地添加样式，但是一个外部的 CSS 文件可以拥有 React 应用程序的所有剩余样式。 一旦您的应用程序增长，还有许多其他样式方案选择。<br>首先，我建议您研究一下 CSS Modules，将其作为 CSS-in-CSS 解决方案之一。 CSS Modules 受到 create-react-app 的支持，并为您提供了将 CSS 封装到模块中的方法。 这样，它就不会意外地泄漏到其他人的样式中。 尽管应用程序的某些部分仍然可以共享样式，但其他部分不必访问它。 在 React 中，CSS Modules 通常将 CSS 文件与 React 组件文件共存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import styles from &#39;.&#x2F;style.css&#39;;</span><br><span class="line">const Headline &#x3D; (&#123; title &#125;) &#x3D;&gt;</span><br><span class="line">  &lt;h1 className&#x3D;&#123;styles.headline&#125;&gt;</span><br><span class="line">    &#123;title&#125;</span><br><span class="line">  &lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>其次，我想推荐的是被称作为 styled components，作为 React 的 CSS-in-JS 解决方案之一。 这个方法是由一个名为 <a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-styled-components">styled-components</a> 的库提供的，它将样式与 JavaScript 共享到 React 组件的旁边:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import styled from &#39;styled-components&#39;;</span><br><span class="line">const BlueHeadline &#x3D; styled.h1&#96;</span><br><span class="line">  color: blue;</span><br><span class="line">&#96;;</span><br><span class="line">const Headline &#x3D; (&#123; title &#125;) &#x3D;&gt;</span><br><span class="line">  &lt;BlueHeadline&gt;</span><br><span class="line">    &#123;title&#125;</span><br><span class="line">  &lt;&#x2F;BlueHeadline&gt;</span><br></pre></td></tr></table></figure>

<p>第三，我想推荐 <a target="_blank" rel="noopener" href="https://tailwindcss.com/">Tailwind CSS</a> 作为一个函数式的 CSS 解决方案:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Headline &#x3D; (&#123; title &#125;) &#x3D;&gt;</span><br><span class="line">  &lt;h1 className&#x3D;&quot;text-blue-700&quot;&gt;</span><br><span class="line">    &#123;title&#125;</span><br><span class="line">  &lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>是否选择 CSS in CSS、 CSS in js 或函数式 CSS 取决于您。 所有的策略都适用于大型的 React 应用程序。<br><strong>建议:</strong></p>
<ul>
<li>CSS-in-CSS with CSS Modules</li>
<li>CSS-in-JS with Styled Components</li>
<li>Functional CSS with Tailwind CSS</li>
</ul>
<h2 id="React-UI-库"><a href="#React-UI-库" class="headerlink" title="React UI 库"></a>React UI 库</h2><p>如果您不想从头开始构建所有必要的 React UI 组件，您可以选择 React UI Library 来完成这项工作。 所有这些都有一些基本的组件，比如按钮，下拉菜单，对话框和列表。 有很多 UI 库可供 React 选择:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ant.design/">Ant Design</a></li>
<li><a target="_blank" rel="noopener" href="https://chakra-ui.com/">Chakra UI</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tailwindui.com/">Tailwind UI </a></li>
<li><a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-semantic-ui-tutorial">Semantic UI </a></li>
<li><a target="_blank" rel="noopener" href="https://material-ui.com/">Material UI </a></li>
<li><a target="_blank" rel="noopener" href="https://react-bootstrap.github.io/">React Bootstrap 1. React Bootstrap</a></li>
</ul>
<h2 id="React-动画"><a href="#React-动画" class="headerlink" title="React 动画"></a>React 动画</h2><p>任何 web 应用程序中的动画都是从 CSS 开始的。 最终你会发现 CSS 动画并不能满足你的需求。 通常开发人员会检查 <a target="_blank" rel="noopener" href="https://reactcommunity.org/react-transition-group/">React Transition Group</a>，这样他们就可以使用 React 组件执行动画。 其他著名的 React 动画库有:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/chenglou/react-motion">react-motion </a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/react-spring/react-spring">react-spring </a></li>
<li><a target="_blank" rel="noopener" href="https://www.framer.com/motion/">Framer Motion</a></li>
<li><a target="_blank" rel="noopener" href="https://facebook.github.io/react-native/docs/animated">Animated </a>(React Native)</li>
</ul>
<p><strong>建议:</strong></p>
<ul>
<li>React Transition Group</li>
</ul>
<h2 id="React-可视化和图表库"><a href="#React-可视化和图表库" class="headerlink" title="React 可视化和图表库"></a>React 可视化和图表库</h2><p>如果你真的想自己从头开始构建图表，你没办法不去学习 <a target="_blank" rel="noopener" href="https://d3js.org/">D3</a> 。 这是一个底层的可视化库，它为你提供了创建令人惊叹的图表所需的一切。 然而，学习 D3 是一个完全不同的冒险，因此许多开发人员只是想选择一个 React 图表库，它可以为他们做任何事情，以换取灵活性。 以下是一些流行的解决方案:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://nivo.rocks/">nivo</a></li>
<li><a target="_blank" rel="noopener" href="https://formidable.com/open-source/victory/">Victory </a></li>
<li><a target="_blank" rel="noopener" href="https://uber.github.io/react-vis/">react-vis</a></li>
<li><a target="_blank" rel="noopener" href="http://recharts.org/">Recharts</a></li>
<li><a target="_blank" rel="noopener" href="https://microsoft.github.io/chart-parts/">Chart Parts </a></li>
</ul>
<h2 id="React-中的表单库"><a href="#React-中的表单库" class="headerlink" title="React 中的表单库"></a>React 中的表单库</h2><p>在 React 中最流行的表单库是 <a target="_blank" rel="noopener" href="https://github.com/jaredpalmer/">Formik</a>。 它提供了从验证到提交到形成状态管理所需的一切。另外一个选择是 <a target="_blank" rel="noopener" href="https://react-hook-form.com/">React Hook Form</a>。 如果您开始使用更复杂的表单，这两种方法对于 React 应用程序都是有效的解决方案。<br><strong>建议:</strong></p>
<ul>
<li>Formik</li>
<li>React Hook Form</li>
</ul>
<h2 id="React-中的数据获取库"><a href="#React-中的数据获取库" class="headerlink" title="React 中的数据获取库"></a>React 中的数据获取库</h2><p>很快，您就必须向远程 API 发出请求，以便在 React 中获取数据。 现代浏览器带有本地获取 API 来执行异步数据请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  React.useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const result &#x3D; fetch(my&#x2F;api&#x2F;domain)</span><br><span class="line">      .then(response &#x3D;&gt; response.json())</span><br><span class="line">      .then(result &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; do success handling</span><br><span class="line">        &#x2F;&#x2F; e.g. store in local state</span><br><span class="line">      &#125;);</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，你不需要添加任何其他库来完成这项工作。 但是，有时候不仅需要提供复杂的异步请求，还需要它们具有更强大的功能，而且只是一个轻量级的库。 我推荐的这些库之一称为 axios。 当您的应用程序增大时，可以使用它来代替本地获取 API。<br>如果您有足够的时间来处理 GraphQL API，我建议您使用 Apollo Client。 可供选择的 GraphQL 客户端将是 urql 或 Relay。<br><strong>建议:</strong></p>
<ul>
<li>浏览器的本地 fetch API</li>
<li>axios</li>
<li>Apollo Client</li>
</ul>
<h2 id="React-类型检查"><a href="#React-类型检查" class="headerlink" title="React 类型检查"></a>React 类型检查</h2><p>幸运的是 React 有自己的类型检查能力。 使用 PropTypes，你可以为你的 React 组件定义传入的 props。 无论何时向组件传递了错误的类型，在运行应用程序时都会收到错误消息。 但是这种形式的类型检查只应该用于较小的应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line">const List &#x3D; (&#123; list &#125;) &#x3D;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;list.map(item &#x3D;&gt; &lt;div key&#x3D;&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;&#x2F;div&gt;)&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">List.propTypes &#x3D; &#123;</span><br><span class="line">  list: PropTypes.array.isRequired,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在较大的 React 应用程序中，TypeScript 为整个应用程序增加了类型安全性，而不是使用 React PropTypes。 当使用这样的类型检查器时，您可以在开发期间获得错误。 您不必启动应用程序就可以找到本可以通过这种类型检查防止的 bug。 这样一来，类型检查器就可以提高您的开发人员体验，避免首先引入 bug。<br><strong>建议:</strong></p>
<ul>
<li>TypeScript</li>
</ul>
<h2 id="React-代码风格"><a href="#React-代码风格" class="headerlink" title="React 代码风格"></a>React 代码风格</h2><p>对于代码风格，基本上有三个选项可以用的。<br>第一种方法是遵循一个被社区所接受的风格指南。 一个流行的 Airbnb 开源的<a target="_blank" rel="noopener" href="https://github.com/airbnb/javascript/tree/master/react">React style guide</a> 。 即使你没有刻意遵循这些样式指南，但是读一读它们，在 React 中获得常见代码样式的要点是有意义的。<br>第二种方法是使用 linter，比如 ESLint。 虽然样式指南只给出建议，但是 linter 在应用程序中强制执行这个建议。 例如，你可以要求遵循流行的 Airbnb 样式指南，你的 IED/编辑器会告诉你每一个错误。<br>第三种也是最流行的方法是使用 Prettier。 它是一个强制的代码格式化程序。 您可以将其集成到编辑器或 IDE 中，使其在每次保存文件时格式化您的代码。 也许它并不总是符合您的口味，但至少您不必再担心自己或团队代码库中的代码格式。 虽然 Prettier 不能取代 ESLint，但是它与 ESLint 的集成非常好。<br><strong>建议:</strong></p>
<ul>
<li>ESLint</li>
<li>Prettier</li>
</ul>
<h2 id="React-认证"><a href="#React-认证" class="headerlink" title="React 认证"></a>React 认证</h2><p>在较大的 React 应用程序中，您可能希望引入具有注册、登录和退出功能的身份验证。 此外，密码重置和密码更改功能往往是需要的。 这些特性远远超出了 React，因为后端应用程序为您管理这些事情。 <br>通常的方法是使用自定义身份验证实现自己的自定义后端应用程序。 如果您不想启动自己的身份验证，可以考虑类似 <a target="_blank" rel="noopener" href="http://www.passportjs.org/">Passport.js</a> 的东西。<br>如果你根本不想关心后端，以下三种解决方案可能适合你:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial/">Firebase</a></li>
<li><a target="_blank" rel="noopener" href="https://auth0.com/">Auth0</a></li>
<li><a target="_blank" rel="noopener" href="https://aws.amazon.com/cognito/">AWS Cognito </a></li>
</ul>
<p>如果您正在寻找身份验证 + 数据库的一体化解决方案，请坚持使用 Firebase 或 AWS。<br>建议:</p>
<ul>
<li>DIY: Custom Backend</li>
<li>Get it off the shelf: Firebase</li>
</ul>
<h2 id="React-主机"><a href="#React-主机" class="headerlink" title="React 主机"></a>React 主机</h2><p>您可以像其他 web 应用程序一样部署和托管 React 应用程序。 如果你想拥有完全的控制权，选择像<a target="_blank" rel="noopener" href="https://m.do.co/c/fb27c90322f3">Digital Ocean</a>这样的。 如果你希望有人来处理所有的事情，如果你已经在使用第三方的身份验证/数据库，Netlify 是一个很受欢迎的解决方案，比如 Firebase，你可以检查他们是否也提供主机服务(比如 Firebase Hosting)。 您还可以使用 S3 的静态站点与 Cloudfront 一起托管。</p>
<h2 id="React-测试"><a href="#React-测试" class="headerlink" title="React 测试"></a>React 测试</h2><p>如果您想深入了解 React 中的测试，请阅读以下内容: <a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-testing-tutorial">How to test components in React</a>。 要点如下: 测试 React 应用程序的主干是 Jest。 它提供了测试运行程序、断言库和监视(spying)/模拟(mocking)/stubbing 功能， 一个全面的测试框架中需要的所有东西。<br>至少，您可以使用 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/test-renderer.html">React-test-renderer</a> 在 Jest 测试中渲染 React 组件。 这已经足以用 jest 来执行所谓的<a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-testing-jest">快照测试</a>了。 快照测试的工作方式如下: 运行测试之后，将创建 React 组件中渲染的 DOM 元素的快照。 当您在某个时间点再次运行测试时，将创建另一个快照，用作前一个快照的差异。 如果 diff 不完全相同，则 Jest 将报错，您要么必须接受快照，要么必须更改组件的实现。<br>最终，您会发现自己在使用 Enzyme 或 React Testing Library (这两个都在 Jest 测试环境中使用)来进行更详细的测试功能集。 这两个库使得在 HTML 元素上呈现组件和模拟事件成为可能。 然后，Jest 用于 DOM 节点上的断言。<br>如果您正在为 React-to-end (E2E)测试寻找测试工具，Cypress 是最受欢迎的选择。<br>建议:</p>
<ul>
<li>Unit/Integration/Snapshot Tests: Jest + React Testing Library</li>
<li>E2E Tests: Cypress 2e test: Cypress</li>
</ul>
<h2 id="用于-React-的工具库"><a href="#用于-React-的工具库" class="headerlink" title="用于 React 的工具库"></a>用于 React 的工具库</h2><p>Javascript 为处理数组、对象、数字、对象和字符串提供了大量内置功能。 React 中最常用的 JavaScript 内置功能之一是内置 <code>map()</code> 数组。 为什么？ 因为您总是必须呈现组件中的列表。 由于 JSX 是 HTML 和 JavaScript 的混合物，所以您可以使用 JavaScript 在数组上进行映射并返回 JSX。 使用 React 创建列表组件变得简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const List &#x3D; (&#123; list &#125;) &#x3D;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;list.map(item &#x3D;&gt; &lt;div key&#x3D;&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;&#x2F;div&gt;)&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>但是，您可能需要选择一个实用程序库来提供更详细的功能。 您甚至可能希望在将这些实用函数链接起来时更加灵活，甚至可以将它们动态地组合在一起。 这时，您将引入一个实用程序库: Lodash 或 Ramda。 对于每一个 JavaScript 开发者来说，Lodash 是一个更加实际的库，而 Ramda 在函数式编程中有一个强大的核心。 请记住，现代 JavaScript 提供了很多开箱即用的特性，现在使用实用程序库的必要性已经降低了。<br><strong>建议:</strong></p>
<ul>
<li>JavaScript</li>
<li>Lodash</li>
</ul>
<h2 id="react-和不可变的数据机构"><a href="#react-和不可变的数据机构" class="headerlink" title="react 和不可变的数据机构"></a>react 和不可变的数据机构</h2><p>原生 JavaScript 提供了大量内置工具来处理数据结构，就像它们是不可变的一样。 但是，如果您和您的团队认为有必要实施不可变的数据结构，最流行的选择之一是 Immer。 就我个人而言，我不使用它，但是任何时候有人问到 JS 中的不变性(immutability)，大家都会指出 Immer，并且这可以加上 redux 或 React hooks。</p>
<h2 id="React-国际化"><a href="#React-国际化" class="headerlink" title="React 国际化"></a>React 国际化</h2><p>当涉及到 <a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-internationalization">React 应用程序的国际化</a> 时，您不仅需要考虑翻译，还需要考虑多元化、日期和货币的格式化，以及其他一些事项。 以下是最受欢迎的处理该问题的库:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/i18next/react-i18next">react-i18next</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/formatjs/react-intl">react-intl</a></li>
<li><a target="_blank" rel="noopener" href="https://lingui.js.org/index.html">LinguiJS</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebookincubator/fbt">FBT</a></li>
</ul>
<p><strong>建议:</strong></p>
<ul>
<li>react-i18next</li>
</ul>
<h2 id="React-富文本编辑器"><a href="#React-富文本编辑器" class="headerlink" title="React 富文本编辑器"></a>React 富文本编辑器</h2><p>当涉及到在 React 中的富文本编辑器时，我只能想到以下内容，因为我没有在 React 中使用任何其他内容:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draftjs.org/">Draft.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ianstormtaylor/slate">Slate</a></li>
</ul>
<h2 id="React-中的支付"><a href="#React-中的支付" class="headerlink" title="React 中的支付"></a>React 中的支付</h2><p>和其他网络应用一样，最常见的支付提供商是 Stripe 和 PayPal。 两者都可以整齐地集成到 React 中。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.paypal.com/docs/checkout/">PayPal </a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/stripe/react-stripe-elements">Stripe Elements </a>或 <a target="_blank" rel="noopener" href="https://stripe.com/docs/payments/checkout">Stripe Checkout</a></li>
</ul>
<h2 id="React-中的时间"><a href="#React-中的时间" class="headerlink" title="React 中的时间"></a>React 中的时间</h2><p>如果你的 React 应用程序正在处理大量的日期和时区，你应该引入一个库来为你管理这些事情。 最受欢迎的库是 <a target="_blank" rel="noopener" href="https://momentjs.com/">moment.js</a>。 更轻量级的替代品是 <a target="_blank" rel="noopener" href="https://github.com/date-fns/date-fns">date-fns</a> 和 <a target="_blank" rel="noopener" href="https://github.com/iamkun/dayjs">Day.js</a>。</p>
<h2 id="Reac-桌面应用"><a href="#Reac-桌面应用" class="headerlink" title="Reac 桌面应用"></a>Reac 桌面应用</h2><p>Electron 是跨平台桌面应用程序的首选框架。 不过，也有其他选择，例如:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://nwjs.io/">NW.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/neutralinojs/neutralinojs">Neutralino.js</a></li>
</ul>
<h2 id="React-的移动开发"><a href="#React-的移动开发" class="headerlink" title="React 的移动开发"></a>React 的移动开发</h2><p>我想把 React 从网络带到移动设备的首选解决方案仍然是 React Native。 如果您是 React Native 开发人员，想要创建一个 Web 应用程序，您应该查看 <a target="_blank" rel="noopener" href="https://github.com/necolas/react-native-web">React Native Web</a>。</p>
<h2 id="REACT-VR-AR"><a href="#REACT-VR-AR" class="headerlink" title="REACT VR/AR"></a>REACT VR/AR</h2><p>实话说，我们很有可能用 React 深入虚拟现实或者增强现实中，我没有使用过这些库中的任何一个，但是它们是我在谈到 React AR/VR 时从大脑闪过的就是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://facebook.github.io/react-360/">React 360</a></li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-viro">react-viro</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/react-native-ar/react-native-arkit">react-native-arkit</a></li>
</ul>
<h2 id="为-React-设计原型"><a href="#为-React-设计原型" class="headerlink" title="为 React 设计原型"></a>为 React 设计原型</h2><p>如果您来自 UI/UX 背景，那么您可能希望使用一个工具为新的 React 组件、布局或 UI/UX 概念进行快速原型设计。 我以前用过 Sketch，但最近转到了 <a target="_blank" rel="noopener" href="https://www.framer.com/">Figma</a>。 尽管我两者都喜欢，但我现在并不后悔使用 Figma。 另一个流行的工具是 Framer。</p>
<h2 id="为-React-书写文档"><a href="#为-React-书写文档" class="headerlink" title="为 React 书写文档"></a>为 React 书写文档</h2><p>如果你负责为你的软件、 UI 库或者其他东西编写文档，那么你可以使用一些简洁的 React 文档工具。 我已经广泛地使用了 Storybook，我可以说他非常好用，但是我也听说了其他解决方案的好处:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://react-styleguidist.js.org/">Styleguidist</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docz.site/">docz</a></li>
<li><a target="_blank" rel="noopener" href="https://docusaurus.io/">Docusaurus</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以最终，React 生态系统可以看作是一个 React 的框架，但它保持灵活性。 它是一个灵活的框架，您可以自己决定选择哪些库。 您可以从小型开始，只添加库来解决特定的问题。 当应用程序增长时，您可以沿途扩展构建块。 否则你可以通过使用普通的 React 来保持轻量级。 因此，这里再次列出了可以补充 React 作为应用程序关于不同项目大小的核心的库。 请记住，这个列表是我的个人看法，我也渴望得到你的反馈。</p>
<h3 id="小型应用程式"><a href="#小型应用程式" class="headerlink" title="小型应用程式"></a>小型应用程式</h3><ul>
<li><strong>样板</strong>: create-react-app</li>
<li><strong>样式库:</strong> basic CSS and inline style</li>
<li><strong>异步请求</strong>: fetch or axios</li>
<li><strong>代码风格:</strong> 无</li>
<li><strong>类型检查:</strong> 无</li>
<li><strong>状态管理:</strong> React Hooks</li>
<li><strong>路由:</strong> 无 or React Router</li>
<li><strong>身份验证:</strong> Firebase</li>
<li><strong>数据库:</strong> Firebase</li>
<li><strong>UI 库:</strong> none</li>
<li><strong>表单库:</strong> 无</li>
<li><strong>测试库:</strong> Jest</li>
<li><strong>实用程序库:</strong> JavaScript</li>
<li><strong>国际化:</strong> react-i18next</li>
<li><strong>React 桌面:</strong> Electron</li>
</ul>
<h3 id="中型应用"><a href="#中型应用" class="headerlink" title="中型应用"></a>中型应用</h3><ul>
<li><strong>样板文件:</strong> Next.js or Gatsby.js</li>
<li><strong>样式库:</strong> CSS Modules or Styled Components</li>
<li><strong>异步请求:</strong> fetch or axios</li>
<li><strong>代码风格:</strong> Prettier，ESLint</li>
<li><strong>类型检查:</strong> 无 或 TypeScript</li>
<li><strong>状态管理:</strong> React Hooks and/or Apollo</li>
<li><strong>路由:</strong> React Router</li>
<li><strong>身份验证:</strong> Firebase</li>
<li><strong>数据库:</strong> Firebase</li>
<li><strong>Ui 库:</strong> none 或 UI 组件库</li>
<li><strong>表单库:</strong> none 或 Formik 或 React Hook Form</li>
<li><strong>测试库:</strong> Jest with React Testing Library</li>
<li><strong>实用程序库:</strong> JavaScript</li>
<li><strong>国际化:</strong> react-i18next</li>
<li><strong>React 桌面:</strong> Electron</li>
</ul>
<h3 id="大型应用程序"><a href="#大型应用程序" class="headerlink" title="大型应用程序"></a>大型应用程序</h3><ul>
<li><strong>样板文件:</strong> Next.js, Gatsby.js, custom setup</li>
<li><strong>样式库:</strong> CSS Modules or Styled Components</li>
<li><strong>异步请求:</strong> axios 或 Apollo Client</li>
<li><strong>代码风格:</strong> Prettier，ESLint</li>
<li><strong>类型检查:</strong> TypeScript</li>
<li><strong>状态管理:</strong> React Hooks and/或者 Apollo/Redux/MobX</li>
<li><strong>路由:</strong> React Router</li>
<li><strong>认证:</strong> Node.js 服务 + Passport.js</li>
<li><strong>数据库:</strong> 自己用 SQL/NoSQL DB 提供 Node.js 服务</li>
<li><strong>Ui 库:</strong> UI 组件库或者您自己的 UI 组件</li>
<li>**表单库:**none 或者 Formik 或者 React Hook Form</li>
<li><strong>测试库:</strong> Jest with React Testing Library and Cypress</li>
<li><strong>实用程序库:</strong> JavaScript 的 api，Lodash</li>
<li><strong>国际化:</strong> react-i18next</li>
<li><strong>React 桌面:</strong> Electron</li>
</ul>
<p>以前的建议是个人的。 您可以为理想的 React 应用程序选择自己的灵活框架。 每一个“理想”的 React 设置都是主观的，取决于开发人员和项目的需求。 毕竟，没有理想的 React 应用程序设置。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpeg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/29/cwban8/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">语雀游戏机🎮</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/05/lws69b/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS大法 - 纯JS 获取客户端IP地址</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By wuyanbin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>